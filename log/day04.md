# 내 PC를 부팅하자

## 부팅과 BIOS

### 부팅

* PC가 켜진 후에 OS가 실행되기 전까지 수행되는 일련의 작업 과정
  * 프로세서 초기화
  * 메모리, 외부 디바이트 검사 및 초기화
  * 부트 로더 메모리에 복사
  * OS 시작

### yeojinux 부팅 과정

---

* BIOS 영역

1. 전원 켜짐
2. POST(Power On Self Test)
   1. 프로세서 초기화
   2. 메모리 검사와 초기화
   3. 주변 장치 검사와 초기화
3. 부트 로더 이미지를 메모리로 복사(0x7C00)
   * BIOS에서 OS로 제어권이 넘어가는 단계
   * 하드 디스크의 가장 앞부분에 존재
   * 부트 로더 코드를 메모리의 0x7C00 어드레스에 복사한 후 프로세서가 수행
   * 부트 로더 코드가 없다면 에러 메시지를 출력하고 작업 중단됨

---

* OS 영역

1. 부트 로더
   1. OS 이미지를 1MB 이하의 메모리로 복사
   2. 보호 모드로 전환
2. 32비트 커널
   1. 64비트 커널을 2MB 이상의 메모리로 복사
   2. IA-32e 모드로 전환
3. 64비트 커널
   1. 멀티코어 설정 및 초기화
   2. 멀티태스킹 모듈 초기화
   3. 메모리 관리 모듈 초기화
   4. 주변 장치 초기화(키보드, 마우스, 하드 디스크, 시리얼)
   5. 그래픽 모드로 전환
   6. 응용프로그램 실행

### BIOS(Basic Input Output System)

* 메인보드에 포함된 펌웨어의 일종
* PC 메인보드 롬이나 플래시 메모리로 존재하며, 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행하는 코드
* 부팅 옵션, 시스템 전반적인 설정 값을 관리하는 역할도 있음
* BIOS의 기능은 인터럽트를 통해 사용 가능

### Boot Loader

* 저장 매체(하드 디스크)의 첫 번째 섹터 MBR(Master Boot Record)에 있는 작은 프로그램
    * MBR에는 파티션 정보도 포함됨
* OS 실행에 필요한 환경을 설정하고 OS 이미지를 메모리에 복사
* 크기는 512바이트로 고정되어 있음

#### 첫 번째 섹터가 부트 로더인지 확인하는 방법

* 읽어들인 512바이트의 마지막 2바이트 값이 0x55, 0xAA인지 검사해서 확인

## 부트 로더 제작과 테스트

### 세상에서 가장 간단한 부트 로더

* 부트 섹터 512바이트에서 마지막 2바이트를 0x55, 0xAA로 저장

#### 어셈블리어 기본

* 사칙 연산

|명령어|설명|
|---|---|
|add A, B|A에 B의 값을 더한 후 A에 저장|
|sub A, B|A에서 B의 값을 뺀 후 A에 저장|
|mul A|AX의 레지스터 값과 A의 값을 곱한 후 AX 또는 DX:AX에 저장|
|inc A|A의 값을 1 중가|
|dec A|A의 값을 1 감소|
|div A|AX나 DX:AX의 값을 A로 나누어 몫과 나머지를 각기 AL, AH 또는 AD, DX에 저장|

* 논리 연산

|명령어|설명|
|---|---|
|and A, B|A에 B의 값을 AND하여 A에 저장|
|or A, B|A에 B의 값을 OR하여 A에 저장|
|xor A, B|A에 B의 값을 XOR하여 A에 저장|
|not A|A의 값을 반전하여 저장|

* 대입 및 분기

|명령어|설명|
|---|---|
|mov A, B|B에서 A로 값을 이동|
|cmp A, B|두 값을 비교하여 결과를 FLAGS 레지스터에 적용|
|jmp A|무조건 해당 어드레스로 이동하여 A 위치의 코드를 실행|
|je, ja, jb, jz, jne, jna, jnb, jnz  A|조건 분기 명령으로 FLAGS 레지스터의 값에 따라 jmp 수행, 일반적으로 값을 비교하는 cmp 명령어와 함께 사용, equal(e), above(a), below(b), zero(z), not(n) 등의 다양한 조건 포함|

* 함수 호출

|명령어|설명|
|---|---|
|call A|스택에 call 명령 다음의 어드레스를 삽입하고 A 위치의 코드를 실행, 함수를 호출하는 용도로 사용|
|ret A|스택을 A만큼 줄인 후에 되돌아갈 어드레스를 꺼내 해당 어드레스의 코드 실행, 일반적으로 call 명령과 짝을 이루어 사용|

* 스택

|명령어|설명|
|---|---|
|push A|A의 값을 스택에 저장|
|pop A|스택에서 값을 꺼내 A에 저장|

* 인터럽트

|명령어|설명|
|---|---|
|int A|A번째 순서의 소프트웨어 인터럽트 발생|
|cli|인터럽트를 발생 불가능하도록 설정|
|sti|인터럽트를 발생 가능하도록 설정|

* 인터럽트

|명령어|설명|
|---|---|
|int A|A번째 순서의 소프트웨어 인터럽트 발생|
|cli|인터럽트를 발생 불가능하도록 설정|

* I/O 포트 제어

|명령어|설명|
|---|---|
|in A, B|I/O 포트 B에서 값을 입력 받아 A에 저장, 주변 장치에서 값을 읽어들이는 용도|
|out B, A|A의 값을 I/O 포트 B에 출력, 주변 장치에 값을 쓰는 용도|

### 화면 버퍼와 화면 제어

* PC 부팅 후 기본 설정 화면 모드는 텍스트 모드
  * 가로 80문자, 세로 25문자이며 비디오 메모리 어드레스는 0xB8000부터 시작
  * 화면에 표시되는 문자 하나는 문자값 1바이트와 속성값 1바이트로 구성
  * 80 * 25 * 2 = 4,000바이트의 비디오 메모리가 필요

#### 텍스트 모드의 화면 구조

* 비트 의미
  
|7|6|5|4|3|2|1|0|
|---|---|---|---|---|---|---|---|
|Attr|BC|BC|BC|Attr|FC|FC|FC|

* FC/BC: 전경색/배경색
  * 0x00: Black
  * 0x01: Blue
  * 0x02: Green
  * 0x03: Cyan
  * 0x04: Red
  * 0x05: Megenta
  * 0x06: Yellow
  * 0x07: White
* Attr: 강조 효과
  * 1일 경우 배경색에 깜빡임 또는 강조 효과, 전경색에 강조 효과
  * 깜빡임과 강조 효과를 나누는 것은 비디오 컨트롤러의 속성 모드 제어 레지스터(Attribute Mode Control Register)에 따라 결정됨

#### 세그먼트 레지스터에 비디오 메모리 어드레스 설정

```assembler
mov     ax, 0xB80   ; AX 레지스터에 0xB800 복사
mov     ds, ax      ; DS 세그먼트 레지스터에 AX 레지스터의 값(0xB800) 복사
```

* 리얼 모드에서는 세그먼트 레지스터에 정의된 기준 주소에 값을 더해서 계산하기 떄문에 ds 레지스터 활용

```assembler
mov     byte[0x00], 'M'     ; DS 세그먼트:오프셋 0xB800:0x0000에 'M' 복사
mov     byte[0x01], 0x4A    ; DS 세그먼트:오프셋 0xB800:0x0001에 0x4A(빨간 배경에 녹색 속성) 복사
```

### 세그먼트 레지스터 초기화와 Hello, World~!

#### 세그먼트 레지스터 초기화

* BIOS가 부트 로더를 실행했을 때 세그먼트 레지스터에는 BIOS가 사용하던 값들이 들어 있기 때문에 초기화가 필요함
  * 책에서는 0x07C0으로 초기화: BIOS가 부트 로더를 디스크에서 읽어 메모리에 복사하는 위치가 0x7C00
  * CS, DS 세그먼트 레지스터를 모드 0x07C0으로 초기화
    * CS 이외 레지스터는 mov 명령을 초기화
    * CS 레지스터는 jmp 명령 사용

```assembler
SECTION .text           ; text 섹션(세그먼트) 정의
jmp 0x07C0:START        ; CS 세그먼트 레지스터에 0x07C0을 복사하면서 START 레이블로 이동
START:
    mov ax, 0x07C0      ; 부트 로더의 시작 어드레스(0x7C00)를 세그먼트 레지스터 값으로 교환
    mov ds, ax          ; DS 세그먼트 레지스터에 설정
    mov ax, 0xB800      ; 비디오 메모리의 시작 어드레스(0xB800)를 세그먼트 레지스터 값으로 변환
    mov es, ax          ; ES 세그먼트 레지스터에 설정
```

* 비디오 출력에 사용하는 코드는 ES 레지스터 사용
  * 암시적으로 세그먼트 레지스터를 사용할 경우 DS를 기본으로 사용함

```assembler
mov     byte[es:0x00], 'M'      ; DS 세그먼트:오프셋 0xB800:0x0000에 'M' 복사
mov     byte[es:0x01], 0x4A     ; DS 세그먼트:오프셋 0xB800:0x0001에 0x4A(빨간 배경에 녹색 속성) 복사
```

#### 부팅 메시지 출력

* 화면 깨끗하게 지우기: 모든 비디오 메모리의 문자 부분을 0으로 채우기

##### **메인 함수가 없으면 에러가 있기 때문에 책과 다르게 수정함**

```c
int i = 0;
char* pcVideoMemory = (char*) 0xB8000;

int main()
{
    while (1)
    {
        pcVideoMemory[i] = 0;
        pcVideoMemory[i+1] = 0x0A;
        i += 2;
        if (i >= 80 * 25 * 2)
        {
            break;
        }
    }
}
```

```shell
$ objdump -d a.o
```

```assembler
Disassembly of section __TEXT,__text:
_main:
       0:       55      pushq   %rbp
       1:       48 89 e5        movq    %rsp, %rbp
       4:       8b 05 00 00 00 00       movl    (%rip), %eax
       a:       66 0f 1f 44 00 00       nopw    (%rax,%rax)
      10:       48 8b 0d 00 00 00 00    movq    (%rip), %rcx
      17:       48 98   cltq
      19:       c6 04 01 00     movb    $0, (%rcx,%rax)
      1d:       48 8b 05 00 00 00 00    movq    (%rip), %rax
      24:       48 63 0d 00 00 00 00    movslq  (%rip), %rcx
      2b:       c6 44 08 01 0a  movb    $10, 1(%rax,%rcx)
      30:       8b 0d 00 00 00 00       movl    (%rip), %ecx
      36:       8d 41 02        leal    2(%rcx), %eax
      39:       89 05 00 00 00 00       movl    %eax, (%rip)
      3f:       81 f9 9e 0f 00 00       cmpl    $3998, %ecx
      45:       7c c9   jl      -55 <_main+0x10>
      47:       31 c0   xorl    %eax, %eax
      49:       5d      popq    %rbp
      4a:       c3      retq
```

##### 책에 나온 어셈블리어 코드

```assembler
mov si, 0                       ; SI 레지스터(문자열 원본 인덱스 레지스터) 초기화
.SCEENCLEARLOOP                 ; 화면을 지우는 루프
    mov byte[es:si], 0          ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자 삭제
    mov byte[es:si + 1], 0x0A   ; 비디오 메모리의 속성이 위치하는 어드레스에 0x0A(검은 바탕에 녹색)을 복사
    add ai, 2                   ; 문자와 속성을 설정했으므로 다음 위치로 이동
    cmp si, 80 * 25 * 2         ; 출력한 문자의 수를 의미하는 SI 레지스터와 비교
    jl .SCEENCLEARLOOP          ; SI 레지스터가 80 * 25 * 2보다 작다면 .SCEENCLEARLOOP 레이블로 이동
```

* 메세지를 출력
  * C언어를 이용해 작성하고 어셈블리어로 바꾸어보기

```c
int i = 0;
int j = 0;
char* pcVideoMemory = (char*) 0xB8000;
char* pcMessage = "MINT64 OS Boot Loader Start~!!";
char cTemp;

while (1)
{
    cTemp = pcMessage[i];
    if (cTemp == 0)
    {
        break;
    }
    pcVideoMemory[j] = cTemp;
    i += 1;
    j += 1;
}
```

```assembler
    mov si, 0   ; SI 레지스터(문자열 원본 인덱스 레지스터) 초기화
    mov di, 0   ; DI 레지스터(문자열 대상 인덱스 레지스터) 초기화

.MESSAGELOOP:   ; 메시지를 출력하는 루프
    mov cl, byte[si + MESSAGE1]     ; MESSAGE1의 어드레스에서 SI 레지스터 값만큼 더한 위치의 문자를 CL 레지스터에 복사, CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
    cmp cl, 0   ; 복사한 문자와 0을 비교
    je .MESSAGEEND      ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료
    mov byte[es:di], cl ; 0이 아니면 비디오 메모리 어드레스 0xB800:di에 문자를 출력
    add si, 1   ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2   ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동, 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로 문자만 출력하려면 2를 더해야 함
    jmp .MESSAGELOOP    ; 메시지 출력 루프로 이동하여 다음 문자를 출력

.MESSAGEEND:

MESSAGE1:       db 'MINT64 OS Boot Loader Start~!!', 0  ; 출력할 메시지 정의, 마지막은 0으로 설정하여 .MESSAGELOOP에서 처리할 수 있게 함
```
