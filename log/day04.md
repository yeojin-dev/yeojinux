# 내 PC를 부팅하자

## 부팅과 BIOS

### 부팅

* PC가 켜진 후에 OS가 실행되기 전까지 수행되는 일련의 작업 과정
  * 프로세서 초기화
  * 메모리, 외부 디바이트 검사 및 초기화
  * 부트 로더 메모리에 복사
  * OS 시작

### yeojinux 부팅 과정

---

* BIOS 영역

1. 전원 켜짐
2. POST(Power On Self Test)
   1. 프로세서 초기화
   2. 메모리 검사와 초기화
   3. 주변 장치 검사와 초기화
3. 부트 로더 이미지를 메모리로 복사(0x7C00)
   * BIOS에서 OS로 제어권이 넘어가는 단계
   * 하드 디스크의 가장 앞부분에 존재
   * 부트 로더 코드를 메모리의 0x7C00 어드레스에 복사한 후 프로세서가 수행
   * 부트 로더 코드가 없다면 에러 메시지를 출력하고 작업 중단됨

---

* OS 영역

1. 부트 로더
   1. OS 이미지를 1MB 이하의 메모리로 복사
   2. 보호 모드로 전환
2. 32비트 커널
   1. 64비트 커널을 2MB 이상의 메모리로 복사
   2. IA-32e 모드로 전환
3. 64비트 커널
   1. 멀티코어 설정 및 초기화
   2. 멀티태스킹 모듈 초기화
   3. 메모리 관리 모듈 초기화
   4. 주변 장치 초기화(키보드, 마우스, 하드 디스크, 시리얼)
   5. 그래픽 모드로 전환
   6. 응용프로그램 실행

### BIOS(Basic Input Output System)

* 메인보드에 포함된 펌웨어의 일종
* PC 메인보드 롬이나 플래시 메모리로 존재하며, 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행하는 코드
* 부팅 옵션, 시스템 전반적인 설정 값을 관리하는 역할도 있음
* BIOS의 기능은 인터럽트를 통해 사용 가능

### Boot Loader

* 저장 매체(하드 디스크)의 첫 번째 섹터 MBR(Master Boot Record)에 있는 작은 프로그램
    * MBR에는 파티션 정보도 포함됨
* OS 실행에 필요한 환경을 설정하고 OS 이미지를 메모리에 복사
* 크기는 512바이트로 고정되어 있음

#### 첫 번째 섹터가 부트 로더인지 확인하는 방법

* 읽어들인 512바이트의 마지막 2바이트 값이 0x55, 0xAA인지 검사해서 확인

## 부트 로더 제작과 테스트

### 세상에서 가장 간단한 부트 로더

* 부트 섹터 512바이트에서 마지막 2바이트를 0x55, 0xAA로 저장

#### 어셈블리어 기본

* 사칙 연산

|명령어|설명|
|---|---|
|add A, B|A에 B의 값을 더한 후 A에 저장|
|sub A, B|A에서 B의 값을 뺀 후 A에 저장|
|mul A|AX의 레지스터 값과 A의 값을 곱한 후 AX 또는 DX:AX에 저장|
|inc A|A의 값을 1 중가|
|dec A|A의 값을 1 감소|
|div A|AX나 DX:AX의 값을 A로 나누어 몫과 나머지를 각기 AL, AH 또는 AD, DX에 저장|

* 논리 연산

|명령어|설명|
|---|---|
|and A, B|A에 B의 값을 AND하여 A에 저장|
|or A, B|A에 B의 값을 OR하여 A에 저장|
|xor A, B|A에 B의 값을 XOR하여 A에 저장|
|not A|A의 값을 반전하여 저장|

* 대입 및 분기

|명령어|설명|
|---|---|
|mov A, B|B에서 A로 값을 이동|
|cmp A, B|두 값을 비교하여 결과를 FLAGS 레지스터에 적용|
|jmp A|무조건 해당 어드레스로 이동하여 A 위치의 코드를 실행|
|je, ja, jb, jz, jne, jna, jnb, jnz  A|조건 분기 명령으로 FLAGS 레지스터의 값에 따라 jmp 수행, 일반적으로 값을 비교하는 cmp 명령어와 함께 사용, equal(e), above(a), below(b), zero(z), not(n) 등의 다양한 조건 포함|

* 함수 호출

|명령어|설명|
|---|---|
|call A|스택에 call 명령 다음의 어드레스를 삽입하고 A 위치의 코드를 실행, 함수를 호출하는 용도로 사용|
|ret A|스택을 A만큼 줄인 후에 되돌아갈 어드레스를 꺼내 해당 어드레스의 코드 실행, 일반적으로 call 명령과 짝을 이루어 사용|

* 스택

|명령어|설명|
|---|---|
|push A|A의 값을 스택에 저장|
|pop A|스택에서 값을 꺼내 A에 저장|

* 인터럽트

|명령어|설명|
|---|---|
|int A|A번째 순서의 소프트웨어 인터럽트 발생|
|cli|인터럽트를 발생 불가능하도록 설정|
|sti|인터럽트를 발생 가능하도록 설정|

* 인터럽트

|명령어|설명|
|---|---|
|int A|A번째 순서의 소프트웨어 인터럽트 발생|
|cli|인터럽트를 발생 불가능하도록 설정|

* I/O 포트 제어

|명령어|설명|
|---|---|
|in A, B|I/O 포트 B에서 값을 입력 받아 A에 저장, 주변 장치에서 값을 읽어들이는 용도|
|out B, A|A의 값을 I/O 포트 B에 출력, 주변 장치에 값을 쓰는 용도|
