# 64비트 프로세서의 이모저모

## 운영 모드

1. 리얼 모드

    * 프로세서의 초기 상태로서 16비트 모드로 동작하며 8086 프로세서와 호환되는 모드
    * 최대 1MB의 주소 공간을 지원

2. 보호 모드

    * 32비트 모드로 동작하며 세그먼트, 페이징, 보호, 멀티태스킹 등의 기능을 제공하는 모드
    * 4GB의 주소 공간을 지원

3. IA-32e 모드

    * 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성
    * 16EB의 주소 공간을 지원하는 모드

4. 시스템 관리 모드

    * 전원 관리나 하드웨어 제어 같은 특수 기능을 제공하는 모드

5. 가상 8086 모드

    * 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드

### 64비트 OS가 갖추어야 할 필수 운영 모드

* 리얼 모드, 보호 모드, IA-32e 모드 중 64비트 서브모드

#### 리얼 모드

* 전원이 켜지거나 리셋될 때 진입하는 모드
* 과거의 16비트 프로세서와 동일하게 동작
* BIOS의 기능을 사용할 수 있음
    * BIOS는 디스크 읽기, 쓰기, 그래픽 모드 전환 기능 등의 기본 기능을 제공하기 때문에 별도의 디바이스 드라이버를 제작하지 않아도 됨
* 리얼 모드의 작업은 OS 이미지를 디스크에서 메모리로 복사하는 것이 주이지만 어셈블리어로 작성해야만 하기 때문에 어려움

#### 보호 모드

* 리얼 모드에서 IA-32e 모드로 진입하기 위한 모드
* 32비트 윈도우나 리눅스OS에서는 기본 모드
* OS의 기본 기능(보호, 멀티태스킹, 세그멘테이션, 페이징 등)을 하드웨어적으로 지원
* IA-32e 모드에서 사용하는 레지스터들을 거의 그대로 사용함

#### IA-32e 모드

* 32비트 호환 모드와 64비트 호환 모드가 있으나 32비트 호환 모드는 보호 모드와 같은 기능을 수행
* 두 모드의 큰 차이는 없음
* 32비트 호환 모드를 통해 64비트 환경에서도 32비트 코드를 그대로 실행할 수 있음
* 주소 공간이 최대 15EB이기 때문에 자료구조가 더 커짐

### 운영 모드 사이의 관계와 운영 모드의 전환

![운영 모드 전환 다이어그램](https://t1.daumcdn.net/cfile/tistory/1521F1484E3C43661E)

## 운영 모드와 레지스터

* 보호 모드 레지스터

![보호 모드 레지스터](https://t1.daumcdn.net/cfile/tistory/222CBC44593178FD20)

* 운영 모드 레지스터

![IA-32e 모드 레지스터](https://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2424AD3C59318081195528)

* 중요한 레지스터는 범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터

### 범용 레지스터

* 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용

#### x86-64 프로세서의 범용 레지스터와 용도

범용 레지스터 이름|용도
---|---
AX|산술 연산을 수행할 때 누산기로 사용
BX|데이터의 어드레스를 지정할 때 데이터 포인터로 사용
CX|루프 또는 문자열의 카운터로 사용
DX|I/O 어드레스를 지정할 때 사용되며, 산술 연산을 수행할 때 보조 레지스터로 사용
SI|문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용
DI|문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용
SP|스택의 포인터로 사용
BP|스택의 데이터에 접근할 때 데이터의 포인터로 사용
R8~15|x86-64 프로세서에서 추가된 범용 레지스터로, 다양한 용도로 사용 가능

* 64비트 레지스터에는 R 접두사가 붙음(e.g. RAX)
* 32비트 레지스터에는 E 접두사(e.g. EAX)나 D 접미사(e.g. R8D)
* 16비트 레지스터는 접두사가 없거나 W 접미사 사용
* 상위 8비트 레지스터는 끝자리가 H로 변경됨(e.g. AH)
* 하위 8비트 레지스터는 끝자기가 L로 변경되거나 L 접미사 사용(e.g. AL, R9L)
* 운영 모드에 따라 접두사를 결합하는 규칙이 있으며 접두사에 따라 명령어가 처리하는 오퍼랜드, 어드레스 크기가 달라짐

#### RIP 상대 어드레스

* RIP 레지스터의 값과 32비트 오퍼랜드를 통해 64비트 주소 공간을 나타냄
* IA-32e 모드라도 기본 오퍼랜드의 값이 32비트이기 때문에 RIP 상대 레지스터를 이용해야만 모든 메모리에 접근 가능
* 점프 명령어에서는 오퍼랜드가 예외적으로 64비트

### 세그먼트 레지스터

* 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할
* 리얼 모드: 고정된 크기의 어드레스 영역 지정
* 보호 모드, IA-32e 모드: 접근 권한, 세그먼트 시작 어드레스와 크기 등을 지정하는 데 사용
* 커널 영역 보호에 사용됨
* 세그멘테이션 기법에 사용되는 레지스터

세그먼트 레지스터 이름|용도
---|---
CS|코드 영역을 가리키는 레지스터, 데이터 이동 명령으로 값을 변경할 수 없으며, 점프 명령이나 인터럽트 관련 명령으로 변경 가능
DS, ES, FS, GS|데이터 영역을 가리키는 레지스터, 데이터 이동 명령으로 값을 변경할 수 있음, DS 레지스터는 데이터 영역에 접근할 때 암시적으로 사용됨, ES 레지스터는 문자열과 관련된 작업을 처리할 때 암시적으로 사용됨, 데이터 영역에 접근하면서 DS 레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용
SS|스택 영역을 가리키는 레지스터, 데이터 이동 명령으로 값을 변경할 수 있음, 스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 암시적으로 사용됨

### 컨트롤 레지스터

* 운영 모드를 변경하고 현재 운영 중인 모드의 특정 기능을 제어하는 레지스터
* x86-64 프로세서에는 CR0~4, CR8의 6개의 컨트롤 레지스터가 존재
* 컨트롤 레지스터는 각 비트마다 사용 용도가 다름
* 컨트롤 레지스터를 바꿀 때에는 사전, 사후 작업이 필요한 경우가 대부분

컨트롤 레지스터 이름|용도
---|---
CR0|운영 모드를 제어하는 레지스터, 리얼 모드에서 보호 모드로 전환하는 역할과 캐시, 페이징 기능 등을 활성화시킴
CR1|프로세서에 의해 예약된 레지스터
CR2|페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터, 페이징 기법을 활성화한 후에는 페이지 폴드 발생 시에만 유효한 값을 가짐
CR3|페이지 디렉터리의 물리 주소와 페이지 캐시에 관련된 기능을 설정하는 레지스터
CR4|프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터, 페이지 크기 확장이나 메모리 영역 확장 등의 기능을 활성화시킴
CR8|태스크 우선순위 레지스터의 값을 제어하는 레지스터, 프로세스 외부에서 발생하는 인터럽트를 걸러주는 필터의 역할, IA-32e 모드에서만 접근 가능
