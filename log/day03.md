# 64비트 프로세서의 이모저모

## 운영 모드와 메모리 관리 기법

### 리얼 모드의 메모리 관리 방식

* 리얼 모드는 최대 1MB까지 주소 공간을 사용하며 세그멘테이션 방식만 지원
* 세그먼트의 크기는 6KB로 고정되어 있으며 세그먼트의 시작 주소(Base Address)는 세그먼트 레지스터에 직접 설정됨

#### 각 세그먼트 레지스터(모두 16비트)

1. CS: 코드 영역
2. DS, ES, FS, GS: 데이터 영역
3. SS: 스택 영역

#### 세그멘테이션 주소 변환 방식

* (세그먼트 레지스터에 16을 곱한 값) + 범용 레지스터
* (2^20 - 16)의 주소 공간을 이용할 수 있음
* 세그먼트의 크기 역시 16비트로 접근할 수 있는 영역이어야 하기 때문에 64KB로 설정되어 있음

### 보호 모드의 메모리 관리 방식

* 보호 모드는 세그멘테이션과 페이징을 모두 지원
* 보호 모드의 세그멘테이션은 세그먼트 레지스터에 주소값을 저장하는 것이 아닌 디스크립터 자료구조의 위치를 설정하는 방식으로 변경됨
   * 위와 같은 이유로 세그먼트 레지스터 대신 세그먼트 셀렉터라는 이름으로 부름

#### 세그먼트 디스크립터

![세그먼트 디스크립터](https://www.cs.cmu.edu/~410/doc/segments/segdesc.gif)

* 세그먼트에 대한 정보를 담고 있는 자료구조
* DPL: 해당 세그먼트에 접근하기 위한 최소 권한으로 0~3 사이의 값을 가지고 있는데 작을 수록 높은 권한을 요구한다는 의미임
  * CPL(Current Privilege Level) 값이 DPL보다 이하의 값이어야 접근할 수 있음
* 보호 모드에서 세그먼트 레지스터는 세그먼트 디스크립터의 위치를 가리키며 GDT(Global Descriptor Table)에 모여 있음
  * GDT: 연속된 디스크립터의 집합으로 최대 8192개의 디스크립터를 포함할 수 있음
  * GDTR: 16비트의 GDT 크기 필드와 32비트 기준 주소 필드로 구성된 자료구조의 물리 주소를 저장함

#### 보호 모드에서 주소를 계산하는 방법

![세그멘테이션과 페이징](http://pds27.egloos.com/pds/201301/15/54/b0159254_50f4bcce8df14.png)

##### 세그멘테이션

* 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 선형 주소 계산
* 선형 주소(세그먼트 디스크립터의 정보)를 바탕으로 물리 메모리 주소를 계산함
* 범용 레지스터의 값이 세그먼트 크기를 넘게 된다면 예외 발생

![보호 모드에서 주소 계산](http://pds26.egloos.com/pds/201301/15/54/b0159254_50f4b0f998913.png)

* 선형 주소는 물리 주소와 일치할 수도 있고 아닐 수도 있지만 작고 간단한 OS에서는 일치시키는 것이 편함

##### 페이징

* 물리 메모리를 페이지라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠 놓은 페이지로 연결하는 방식
  * 주소 공간을 더 넓게 사용할 수 있는 장점
  * 같은 물리 페이지를 여러 선형 주소에 연결함으로써 응용프로그램끼리 공유하는 메모리를 손쉽게 처리할 수 있고, 그 반대도 가능함

* 물리 메모리를 4KB로 나누고 선형 주소를 3단계로 구분하는 방식 또는 4MB + 2단계로 선형 주소를 구분하는 방식 2가지가 있음

##### 페이지 디렉터리 엔트리와 페이지 테이블 엔트리

![페이지 디렉토리](https://t1.daumcdn.net/cfile/tistory/251D633554D1C8EA06)

![페이지 테이블 엔트리](http://cfile219.uf.daum.net/R400x0/13791E414ECA7193282503)

* 메모리 공간에 존재하는 자료구조
* CR3 컨트롤 레지스터에 페이지 디렉터리의 시작 주소를 저장함

1. CR3 레지스터에 설정된 어드레스로 페이지 디렉터리의 시작 주소를 찾는다.
2. 페이지 디렉터리의 시작 주소에 선형 주소의 디렉터리 오프셋을 이용해서 해당 디렉터리 엔트리를 찾는다. (디렉터리 엔트리에 설정된 값이 페이지 테이블의 시작 주소)
3. 페이지 테이블의 시작 주소에 선형 주소의 테이블 오프셋을 이용해서 해당 페이지 테이블 엔트리를 찾는다. (페이지 테이블 엔트리에 설정된 값이 4KB 페이지의 시작 주소)
4. 페이지의 시작 주소에 선형 주소의 페이지 오프셋 값을 더해 실제 물리 주소로 변환한다.

### IA-32e 모드의 메모리 관리

* IA-32e 모드에는 서브 모드로 호환 모드와 64비트 모드가 있는데 여기서 호환 모드는 보호 모드와 동일
* 64비트 모드의 주소 공간은 2^64바이트(16EB)
* 아래 설명에서 64비트 모드란 IA-32e 모드의 서브 모드로서의 64비트 모드임

#### 64비트 모드의 세그멘테이션

![64비트 모드의 세그멘테이션](https://qpakzk.gitbooks.io/operating-systems-development/book/img/chap03-14.png)

1. 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계 없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정됨
  * 보호 모드의 세그먼트 디스크립터는 32비트 기준이기 때문
  * 64비트 모드에서는 선형 주소를 기준 주소가 다른 여러 세그먼트로 구분할 수 없음(페이징을 사용해야만 함)
2. 호환 모드와 64비트 모드를 구분하기 위해 코드 세그먼트 디스크립터에 L 필드(비트21) 추가됨: 0이면 호환 모드, 1이면 64비트 모드

#### 64비트 모드의 페이징

* 주소 공간이 64비트이기 때문에 PAE(Page Address Extension) 필수
  * 4KB 페이지는 5단계, 2MB 페이지는 4단계로 구성
  * 페이지 맵 레벨 4 테이블, 디렉터리 포인터 테이블이 추가됨
* 실제로는 서버용 프로세서가 40비트 주소 공간을 지원하고 가정용 프로세서는 64GB~128GB 정도까지만 지원함

![64비트 모드의 페이지 테이블 엔트리](http://pds26.egloos.com/pds/201301/15/54/b0159254_50f4fa10bb451.png)

* 위 그림에서 하위 4바이트는 32비트 엔트리와 같고 상위 4바이트에서 페이지 기준 주소의 확장, 0으로 예약된 구간, 임의 사용 가능 구간, EXB 비트로 구성되어 있음

##### EXB 비트

* 해당 페이지에서 명령어가 실행되는 것을 막는 필드
* 데이터 영역의 명령어가 실행되지 않도록 보안 수준을 높임
  * 버퍼 오버플로우, 스택 오버플로우 공격을 막을 수 있음
* 만약 명령어를 실행하려고 하면 페이지 폴트가 발생함
