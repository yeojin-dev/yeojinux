# 32비트 보호 모드로 전환하자

* 리얼 모드에서 보호 모드로 변환하는 6가지 단계
  * 세그먼트 디스크립터, GDT를 필수로 생성해두어야 함

1. 세그먼트 디스크립터 생성(보호 모드 코드와 데이터용 세그먼트 디스크립터 생성)
2. GDT 정보 생성(세그먼트 디스크립터의 시작 어드레스와 디스크립터의 전체 크기 저장)
3. 프로세서에 GDT 정보 설정(GDTR 레지스터에 GDT의 시작 어드레스와 크기 설정)
4. CR0 컨트롤 레지스터 설정(CR0 컨트롤 레지스터의 PE 비트 1, PG 비트 0)
5. jmp 명령으로 CS 세그먼트 셀렉터 변경과 보호 모드로 전환(jmp 0x08:보호 모드 커널의 시작 어드레스)
6. 각종 세그머트 셀렉터 및 스택 초기화(DS, ES, FS, GS, SS 세그먼트 셀렉터와 ESP, EBP 레지스터 초기화)
7. 보호 모드 커널 실행

## 세그먼트 디스크립터 생성

* 보호 모드의 세그먼트 디스크립터는 8바이트
* 세그먼트는 메모리 공간을 임의의 크기로 나눈 영역을 의미, 세그먼트 디스크립터는 세그먼트에 대한 정보를 나타냄
  * 코드 세그먼트 디스크립터: 실행 가능한 코드가 포함된 세그먼트에 대한 정보로 CS 세그먼트 셀렉터에 사용
  * 데이터 세그먼트 디스크립터: 데이터가 포함된 세그먼트에 대한 정보를 나타내며, CS 세그먼트 셀렉터를 제외한 나머지 셀렉터에 사용됨
    * 스택 영역 역시 데이터 세그먼트 디스크립터 사용

![세그먼트 디스크립터](https://www.cs.cmu.edu/~410/doc/segments/segdesc.gif)

|필드|의미|
|---|---|
|기준 주소|세그먼트의 시작 어드레스, 32비트 크기이며 0~4GB까지 설정 가능|
|세그먼트 크기|세그먼트의 크기, 20비트 크기, G비트가 0이면 0~1MB까지 설정 가능|
|타입|세그먼트 타입, 코드 또는 데이터 세그먼트로 설정 가능|
|S|디스크립터 타입, 1로 설정할 경우 세그먼트 디스크립터, 0일 경우 시스템 디스크립터|
|DPL|Descriptor Privilege Level, 디스크립터 사용에 필요한 권한을 의미, 0~3의 범위를 가지고 있으며 CPL(Current Privilege Level), RPL(Requested Privilege Level)과 조합되어 접근 권한을 제한하는 데 사용|
|P|Present, 현재 디스크립터가 유효한 디스크립터인지 표시, 1로 설정하면 유효한 디스크립터임을 나타내며, 0으로 설정하면 유효하지 않은 디스크립터임을 나타냄|
|AVL|Available, OS가 임의의 용도로 사용할 수 있는 영역|
|L|IA-32e 모드에서 사용하는 필드로 64비트 코드 세그먼트나 32비트 코드 세그먼트를 의미 1로 설정하면 IA-32e 모드의 64비트용 코드 세그먼트, 0으로 설정하면 IA-32e 모드의 32비트 호환 모드용 코드 세그먼트|
|D/B|Default Operation Size, 1로 설정하면 32비트용 세그먼트임을 나타내며 0으로 설정하면 16비트용 세그먼트임을 나타냄|
|G|Granularity, 디스크립터의 세그먼트 크기 필드에 곱해질 가중치, 1로 설정하면 세그먼트 크기에 4KB를 곱하며, 0으로 설정하면 곱하지 않음|

* MINT64 OS에 필요한 세그먼트
1. 커널 코드와 데이터용 세그먼트 디스크립터 각 1개
2. 커널 코드와 데이터용 세그먼트는 0~4GB까지 모든 영역에 접근할 수 있어야 함
3. 보호 모드용 코드와 데이터에 사용할 기본 오퍼랜드 크기는 32비트여야 함
4. 보호 기능은 사용하지 않으며 프로세서의 명령을 사용하는 데 제약이 없어야 하므로 최상위 권한(0)이어야 함

### 코드 세그먼트 디스크립터와 데이터 세그먼트 디스크립터 타입 설정

* 코드 세그먼트와 데이터 세그먼트는 세그먼트 디스크립터이므로 간단하게 S 필드의 값을 1로 설정
* 세그먼트 타입은 4비트 크기의 타입 필드 사용
    1. 코드 세그먼트는 실행/읽기 타입
    2. 데이터 세그먼트는 읽기/쓰기 타입으로 설정

![타입 필드의 값과 의미](https://t1.daumcdn.net/cfile/tistory/224DA53C57FCD71C28)

* 비트 8의 접근 여부 비트는 프로세서에서 설정하는 비트로 프로세스는 해당 디스크립터가 참조될 때마다 비트 8을 1로 설정
* 비트 10의 역방향 확장 비트는 아래로(상위에서 하위 어드레스) 자라는 스택을 위한 옵션, 1로 설정하면 세그먼트 크기 값이 기준 주소에서 아래 방향(0바이트 방향)으로 적용되어 스택의 변화에 맞춰 세그먼트 크기를 동적으로 변경 가능
* 비트 10의 접근 승인 비트는 권한에 관계 없이 해당 코드 세그먼트에 접근할 수 있음을 나타냄, 1로 설정하면 애플리케이션도 커널 코드를 직접 실행 가능함

### 세그먼트의 영역 설정

* MINT64 OS의 커널 세그먼트 디스크립터는 4GB 전체 영역에 접근할 수 있어야 함
* 기준 주소는 20비트로 1MB까지의 주소만 표현할 수 있음
* G비트를 1로 설정하면 크기 필드에 4KB를 곱한 값을 실제 세그먼트 크기로 설정할 수 있음
    * 1MB * 4KB = 4GB 영역이 32비트 시스템의 최대 메모리 영역

### 기본 오퍼랜드 크기와 권한 설정

* 32비트 모드이기 때문에 기본 오퍼랜드 크기 역시 32비트
* D/B 필드값으로 기본 오퍼랜드 크기 결정
* 64비트 모드에서는 L비트를 이용해 32비트 오퍼랜드 사용 가능함
* MINT64 OS의 보호 모드는 권한을 따로 구분하지 않으므로 권한 필드를 모두 최상위 권한(0)으로 설정

### 기타 필드 설정

* P필드의 값을 1로 설정해서 해당 디스크립터를 사용할 수 있도록 함
* AVL필드는 따로 사용하지 않기 때문으로 0으로 설정

### 세그먼트 디스크립터 생성 코드

```assembly
CODEDESCRIPTOR:
    dw 0xFFFF       ; Limit[15:0]
    dw 0x0000       ; Base[15:0]
    db 0x00         ; Base[23:16]
    db 0x9A         ; P=1, DPL=0, Code Segment, Excute/Read
    db 0xCF         ; G=1, D/B=1, L=0, Limit[19:16]
    db 0x00         ; Base[31:24]

DATADESCRIPTOR:
    dw 0xFFFF       ; Limit[15:0]
    dw 0x0000       ; Base[15:0]
    db 0x00         ; Base[23:16]
    db 0x92         ; P=1, DPL=0, Data Segment, Read/Write
    db 0xCF         ; G=1, D/B=1, L=0, Limit[19:16]
    db 0x00         ; Base[31:24]
```
